<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body {
            display: flex;
        }
        form {
            display:inline;
            vertical-align:top;
        }

        input {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body>

<canvas id="canvas" width="800" height="600"></canvas>
<form id="login" method="get" action="#">
    <input type="text" id="user" name="user" value="x" placeholder="Username"/>
    <input type="text" id="pass" name="pass" value="x" placeholder="Password"/>
    <input type="submit" value="New Connection">
</form>

<script src="js_client.js"></script>
<script>
const Module = WallixModule({
    TOTAL_MEMORY: 16777216, // 16**6
    // TOTAL_MEMORY: 268435456, // 16**7
});

const createRdpClient = (function(Module) {
    const HEAPU8 = Module.HEAPU8;
    const HEAP16 = Module.HEAP16;
    const identity = (x) => x;

    const wrappersCbDraw = {
        drawImage: function(cb) {
            return function(idata, w, h, dx, dy, sz, sy, dw, dh) {
                const data = HEAPU8.subarray(idata, idata + w * h * 4);
                const image = new ImageData(new Uint8ClampedArray(data), w, h);
                cb(image, dx, dy, sz, sy, dw, dh);
            };
        },

        drawPolyline: function(cb) {
            return function(xStart, yStart, numDeltaEntries, deltaEntries, penColor) {
                const datas = HEAP16.subarray(deltaEntries, deltaEntries + numDeltaEntries * 2);
                cb(xStart, yStart, deltas, penColor)
            };
        },

        drawRect: identity,
        drawSrcBlt: identity,
        drawLineTo: identity,
    }

    const wrappersCb = {
        ...wrappersCbDraw,
        socketOpen: identity,
        socketClose: identity,
        socketMessage: identity,
        socketAfterMessage: identity,
        socketError: identity,
        socketSend: identity,
    }

    Module.RdpClientEventTable = {};

    const noop = function(){};

    return function(url, username, password, verbosity) {
        const socket = new WebSocket(url, "RDP");
        socket.binaryType = 'arraybuffer';

        let rdpclient = null;
        const events = {};

        const client = {
            on: function(eventName, cb) {
                const wrapCb = wrappersCb[eventName];
                if (!wrapCb) {
                    console.log('RdpClient: Unknown event ' + eventName);
                    return false;
                }
                events[eventName] = wrapCb(cb);
                return this;
            },
            close: noop
        };

        const send_data = function() {
            const out = rdpclient.getSendingData()
            if (out.length) {
                // console.log("send " + out.length + " bytes")
                const cb = events.socketSend;
                if (cb) {
                    cb(out);
                }
                socket.send(out);
                rdpclient.clearSendingData();
            }
        };

        let timeoutID = -1;
        let timeoutDate = 0xffffffff;
        const timer_action = function() {
            const now = Data.now();
            const timeout = rdpclient.updateTime();
            send_data();
            timeoutDate = now + timeout;
            timeoutID = setTimeout(timer_action, timeout);
        }
        const update_timer = function(nextDate) {
            if (nextDate < timeoutDate) {
                timeoutDate = nextDate;
                clearTimeout(timeoutID);
                timeoutID = setTimeout(timer_action, Math.max(0, nextDate - Data.now()));
            }
        }

        const finally_ = function(cb, event) {
            try {
                if (cb) {
                    cb(event);
                }
            }
            finally {
                if (rdpclient) {
                    if (timeoutID) {
                        clearTimeout(timeoutID);
                    }
                    rdpclient.delete();
                    rdpclient = null;
                }
            }
        }

        socket.onopen = function(event) {
            const cb = events.socketOpen;
            if (cb) {
                cb(event);
            }

            client.close = function() {
                socket.close();
            };
            rdpclient = new Module.RdpClient(username || "", password || "", verbosity || 0);
            for (eventName in wrappersCbDraw) {
                rdpclient[eventName] = console.log.bind(console, eventName);
            }

            Module.RdpClientEventTable[rdpclient.thisptr()] = events;

            rdpclient.updateTime();
            timeoutDate = Date.now();
            send_data();
        };

        socket.onmessage = function(event) {
            const cb1 = events.socketMessage;
            if (cb1) {
                cb1(event);
            }

            rdpclient.addReceivingData(event.data);
            const now = Date.now();
            const timeout = rdpclient.updateTime();
            send_data();
            const nextDateTimer = now + timeout;
            if (nextDateTimer < timeoutDate) {
                timeoutDate = nextDateTimer;
                clearTimeout(timeoutID);
                timeoutID = setTimeout(timer_action, Math.max(0, nextDateTimer - Data.now()));
            }

            const cb2 = events.socketAfterMessage;
            if (cb2) {
                cb2(event);
            }
        };

        socket.onerror = function(event) {
            finally_(events.socketError);
        };

        socket.onclose = function(event) {
            finally_(events.socketClose);
        };

        return client;
    }
})(Module);

const canvas = document.getElementById('canvas').getContext('2d');
const login = document.getElementById('login');
const user_input = document.getElementById('user');
const pass_input = document.getElementById('pass');
let rdpclient;

function has_intersection(x1,y1,w1,h1,x2,y2,w2,h2)
{
    return ((x2 >= x1 && x2 < x1 + w1) || (x1 >= x2 && x1 < x2 + w2))
        && ((y2 >= y1 && y2 < y1 + h1) || (y1 >= y2 && y1 < y2 + h2));
}

const scrROp = new Array(255);
scrROp[0x00] = 'darken';
scrROp[0xF0] = 'source-over';
scrROp[0xCC] = 'source-over';
scrROp[0x55] = 'xor';
scrROp[0xFF] = 'lighten';

function run()
{
    rdpclient = createRdpClient(
        "ws://localhost:8080",
        user_input.value,
        pass_input.value,
        0/*xff*/);
    rdpclient.on('socketClose', () => console.log('RdpClient close'));
    rdpclient.on('drawImage', canvas.putImageData.bind(canvas));
    rdpclient.on('drawRect', function(x, y, w, h, color) {
        canvas.fillStyle = color;
        canvas.fillRect(x,y,w,h);
    });
    rdpclient.on('drawSrcBlt', function(sx, sy, w, h, dx, dy, rop) {
        const sourceImageData = canvas.getImageData(sx, sy, w, h);
        const op = scrROp[rop]
        if (op) {
            if (has_intersection(x,y,w,h,dx,dy,w,h)) {
                canvas.globalCompositeOperation = op
                canvas.drawImage(sourceImageData, dx, dy);
                canvas.globalCompositeOperation = 'source-over'
            }
            else {
                canvas.putImageData(sourceImageData, dx, dy);
            }
        }
    });
    rdpclient.on('drawLineTo', function(backMode, nXStart, nYStart, nXEnd, nYEnd, backColor, penStyle, penWidth, penColor) {
		canvas.save();
		canvas.beginPath();
		canvas.moveTo(nXStart, nYStart);
		canvas.lineTo(nXEnd, nYEnd);
		canvas.lineWidth = penWidth;
		canvas.fillStyle = backColor;
		canvas.strokeStyle = penColor;
		switch (penStyle) {
		case 1: canvas.setLineDash([ 10, 6, 10, 6 ]); break;
		case 2: canvas.setLineDash([ 3, 3, 3, 3 ]); break;
		case 3: canvas.setLineDash([ 9, 6, 3, 6 ]); break;
		case 4: canvas.setLineDash([ 9, 3, 3, 3 ]); break;
		default: canvas.setLineDash([ 16, 0, 16, 0 ]);
		}
		canvas.setLineDash([ 16, 0, 16, 0 ]);
		// BackMode does not imply the transparency level of what is about too be drawn
        // canvas.globalAlpha = (backMode == 1 /* TRANSPARENT */? 0.0 : 1.0);
		canvas.stroke();
		canvas.restore();
    });
    rdpclient.on('drawPolyline', function(xStart, yStart, deltas, penColor) {
		canvas.save();
		canvas.strokeStyle = penColor;
		canvas.beginPath();
		canvas.moveTo(xStart, yStart);
        let endx = xStart;
        let endy = yStart;
        const iend = deltas.length
		for (let i = 0; i < iend; i += 2) {
			endx += deltas[i];
			endy += deltas[i+1];
			canvas.lineTo(endx, endy);
		}
		canvas.stroke();
		canvas.restore();
    });
}

login.onsubmit = (e) => {
    e.preventDefault();
    if (rdpclient) {
        rdpclient.close();
    }
    run();
};

canvas.fillStyle = 'black';
canvas.fillRect(0,0,800,600);

const stringvalues = document.URL.split('?')[1];
if (stringvalues) {
    const inputs = {user: user_input, pass: pass_input};
    for (const strvalue of stringvalues.split('&')) {
        const kv = strvalue.split('=');
        const input = inputs[kv[0]]
        if (input) {
            input.value = kv[1].replace('#')
        }
    }
}

run();

// const bytearray = new Uint8Array(event.data)
// let text = ""
// // console.log('Received Binary Message of ' + bytearray.length + ' bytes')
// for (let byte of bytearray) {
//     text += ":" + (byte+0x10000).toString(16).substr(-2)
// }
// console.log("Server Says: " + text)
</script>

</body>
</html>
