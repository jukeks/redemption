<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body {
            display: flex;
        }
        form {
            display:inline;
            vertical-align:top;
        }

        input {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body>

<canvas id="canvas" width="800" height="600"></canvas>
<form id="login" method="get" action="#">
    <input type="text" id="user" name="user" value="x" placeholder="Username"/>
    <input type="text" id="pass" name="pass" value="x" placeholder="Password"/>
    <input type="submit" value="New Connection">
</form>

<script src="js_client.js"></script>
<script>
const Module = WallixModule({
    TOTAL_MEMORY: 16777216, // 16**6
    // TOTAL_MEMORY: 268435456, // 16**7
});

const createRdpClient = (function(Module) {
    const HEAPU8 = Module.HEAPU8;
    const HEAP16 = Module.HEAP16;
    const identity = (x) => x;

    const wrappersCbDraw = {
        drawImage: function(cb) {
            return function(idata, w, h, dx, dy, sz, sy, dw, dh) {
                const data = HEAPU8.subarray(idata, idata + w * h * 4);
                const image = new ImageData(new Uint8ClampedArray(data), w, h);
                cb(image, dx, dy, sz, sy, dw, dh);
            };
        },

        drawPolyline: function(cb) {
            return function(xStart, yStart, numDeltaEntries, deltaEntries, penColor) {
                const datas = HEAP16.subarray(deltaEntries, deltaEntries + numDeltaEntries * 2);
                cb(xStart, yStart, deltas, penColor)
            };
        },

        drawRect: identity,
        drawSrcBlt: identity,
        drawLineTo: identity,
    }

    const wrappersCb = {
        ...wrappersCbDraw,
        socketOpen: identity,
        socketClose: identity,
        socketMessage: identity,
        socketAfterMessage: identity,
        socketError: identity,
        socketSend: identity,
    }

    Module.RdpClientEventTable = {};

    const noop = function(){};

    return function(url, username, password, verbosity) {
        const socket = new WebSocket(url, "RDP");
        socket.binaryType = 'arraybuffer';

        let rdpclient = null;
        const events = {};

        const client = {
            on: function(eventName, cb) {
                const wrapCb = wrappersCb[eventName];
                if (!wrapCb) {
                    console.log('RdpClient: Unknown event ' + eventName);
                    return false;
                }
                events[eventName] = wrapCb(cb);
                return this;
            },
            sendUnicode: noop,
            sendScancode: noop,
            close: noop
        };

        const send_data = function() {
            const out = rdpclient.getSendingData()
            if (out.length) {
                // console.log("send " + out.length + " bytes")
                const cb = events.socketSend;
                if (cb) {
                    cb(out);
                }
                socket.send(out);
                rdpclient.clearSendingData();
            }
        };

        let timeoutID = -1;
        let timeoutDate = 0xffffffff;
        const timer_action = function() {
            const now = Data.now();
            const timeout = rdpclient.updateTime();
            send_data();
            timeoutDate = now + timeout;
            timeoutID = setTimeout(timer_action, timeout);
        }
        const update_timer = function(nextDate) {
            if (nextDate < timeoutDate) {
                timeoutDate = nextDate;
                clearTimeout(timeoutID);
                timeoutID = setTimeout(timer_action, Math.max(0, nextDate - Data.now()));
            }
        }

        const finally_ = function(cb, event) {
            try {
                if (cb) {
                    cb(event);
                }
            }
            finally {
                if (rdpclient) {
                    if (timeoutID) {
                        clearTimeout(timeoutID);
                    }
                    rdpclient.delete();
                    rdpclient = null;
                }
            }
        }

        socket.onopen = function(event) {
            const cb = events.socketOpen;
            if (cb) {
                cb(event);
            }

            client.close = function() {
                socket.close();
            };
            rdpclient = new Module.RdpClient(username || "", password || "", verbosity || 0);
            for (eventName in wrappersCbDraw) {
                rdpclient[eventName] = console.log.bind(console, eventName);
            }
            client.sendUnicode = rdpclient.sendUnicode.bind(rdpclient);
            client.sendScancode = rdpclient.sendScancode.bind(rdpclient);

            Module.RdpClientEventTable[rdpclient.thisptr()] = events;

            rdpclient.updateTime();
            timeoutDate = Date.now();
            send_data();
        };

        socket.onmessage = function(event) {
            const cb1 = events.socketMessage;
            if (cb1) {
                cb1(event);
            }

            rdpclient.addReceivingData(event.data);
            const now = Date.now();
            const timeout = rdpclient.updateTime();
            send_data();
            const nextDateTimer = now + timeout;
            if (nextDateTimer < timeoutDate) {
                timeoutDate = nextDateTimer;
                clearTimeout(timeoutID);
                timeoutID = setTimeout(timer_action, Math.max(0, nextDateTimer - Data.now()));
            }

            const cb2 = events.socketAfterMessage;
            if (cb2) {
                cb2(event);
            }
        };

        socket.onerror = function(event) {
            finally_(events.socketError);
        };

        socket.onclose = function(event) {
            finally_(events.socketClose);
        };

        return client;
    }
})(Module);

const canvas = document.getElementById('canvas').getContext('2d');
const login = document.getElementById('login');
const user_input = document.getElementById('user');
const pass_input = document.getElementById('pass');
let rdpclient;

function has_intersection(x1,y1,w1,h1,x2,y2,w2,h2)
{
    return ((x2 >= x1 && x2 < x1 + w1) || (x1 >= x2 && x1 < x2 + w2))
        && ((y2 >= y1 && y2 < y1 + h1) || (y1 >= y2 && y1 < y2 + h2));
}

const scrROp = new Array(255);
scrROp[0x00] = 'darken';
scrROp[0xF0] = 'source-over';
scrROp[0xCC] = 'source-over';
scrROp[0x55] = 'xor';
scrROp[0xFF] = 'lighten';

const KBD_FLAGS_EXTENDED  = 0x0100
const KBD_FLAGS_EXTENDED1 = 0x0200
const KBD_FLAGS_DOWN      = 0x4000
const KBD_FLAGS_RELEASE   = 0x8000

const keymap = {
    Alt: [0x00000038, 0],
    AltGr: [0x00000138, KBD_FLAGS_EXTENDED],
    Apps: [0x0000015d, 0],
    ArrowDown: [0x00000150, 0],
    ArrowLeft: [0x0000014b, 0],
    ArrowRight: [0x0000014d, 0],
    ArrowUp: [0x00000148, 0],
    Backspace: [0x0000000e, 0],
    BracketLeft: [0x0000001a, 0],
    CapsLock: [0x0000003a, 0],
    ContextMenu: [0x0000015d, 0],
    Control: [0x0000001d, 0],
    extControl: [0x0000011d, 0],
    DeadCircumflex: [0x0000001a, 0],
    DeadUmlaut: [0x0000001a, 0],
    Del: [0x00000153, 0],
    Delete: [0x00000153, 0],
    Digit0: [0x0000000b, 0],
    Digit7: [0x00000008, 0],
    Down: [0x00000150, 0],
    End: [0x0000014f, 0],
    Enter: [0x0000001c, 0],
    Esc: [0x00000001, 0],
    Escape: [0x00000001, 0],
    F1: [0x0000003b, 0],
    F10: [0x00000044, 0],
    F11: [0x00000057, 0],
    F12: [0x00000058, 0],
    F2: [0x0000003c, 0],
    F3: [0x0000003d, 0],
    F4: [0x0000003e, 0],
    F5: [0x0000003f, 0],
    F6: [0x00000040, 0],
    F7: [0x00000041, 0],
    F8: [0x00000042, 0],
    F9: [0x00000043, 0],
    Home: [0x00000147, 0],
    Insert: [0x00000152, 0],
    Left: [0x0000014b, 0],
    Menu: [0x0000015d, 0],
    NumLock: [0x00000145, 0],
    'numpad*': [0x00000037, 0],
    'numpad.': [0x00000053, 0],
    'numpad/': [0x00000135, 0],
    'numpad-': [0x0000004a, 0],
    'numpad+': [0x0000004e, 0],
    numpad0: [0x00000052, 0],
    numpad1: [0x0000004f, 0],
    numpad2: [0x00000050, 0],
    numpad3: [0x00000051, 0],
    numpad4: [0x0000004b, 0],
    numpad5: [0x0000004c, 0],
    numpad6: [0x0000004d, 0],
    numpad7: [0x00000047, 0],
    numpad8: [0x00000048, 0],
    numpad9: [0x00000049, 0],
    numpadAdd: [0x0000004e, 0],
    numpadArrowDown: [0x00000050, 0],
    numpadArrowLeft: [0x0000004b, 0],
    numpadArrowRight: [0x0000004d, 0],
    numpadArrowUp: [0x00000048, 0],
    numpadClear: [0x0000004c, 0],
    numpadDecimal: [0x00000053, 0],
    numpadDel: [0x00000053, 0],
    numpadDelete: [0x00000053, 0],
    numpadDivide: [0x00000135, 0],
    numpadDown: [0x00000050, 0],
    numpadEnd: [0x0000004f, 0],
    numpadEnter: [0x0000011c, 0],
    numpadHome: [0x00000047, 0],
    numpadInsert: [0x00000052, 0],
    numpadLeft: [0x0000004b, 0],
    numpadMultiply: [0x00000037, 0],
    numpadPageDown: [0x00000051, 0],
    numpadPageUp: [0x00000049, 0],
    numpadRight: [0x0000004d, 0],
    numpadSubtract: [0x0000004a, 0],
    numpadUp: [0x00000048, 0],
    OS: [0x0000015b, KBD_FLAGS_EXTENDED],
    Meta: [0x0000015b, 0],
    PageDown: [0x00000151, 0],
    PageUp: [0x00000149, 0],
    PrintScreen: [0x00000137, KBD_FLAGS_EXTENDED],
    Scroll: [0x00000046, 0],
    ScrollLock: [0x00000046, 0],
    Pause: [0x00000045, 0],
    Quote: [0x00000028, 0],
    Right: [0x0000014d, 0],
    Shift: [0x0000002a, 0],
    Spacebar: [0x00000039, 0],
    Tab: [0x0000000f, 0],
    Win: [0x0000015b, KBD_FLAGS_EXTENDED],
}

// let stateKey = 0;
function onKeyEvent(flag, evt)
{
    if (evt.key.length === 1) {
        evt.preventDefault();
        // const newSateKey
        //     = (evt.altKey ? 1 : 0)
        //     + (evt.ctrlKey ? 2 : 0)
        //     + (evt.metaKey ? 4 : 0)
        //     + (evt.shifKey ? 8 : 0);
        // if (stateKey !== newSateKey) {
        //     stateKey = newSateKey
        // }
        console.log(evt.key, evt.key.charCodeAt(0))
        rdpclient.sendUnicode(evt.key.charCodeAt(0), flag);
    }
    else {
        const m = keymap[evt.key];
        if (m) {
            console.log(evt.key, m[0], m[1])
            rdpclient.sendScancode(m[0], flag | m[1]);
        }
    }
}

const onKeyEventUp = (e) => { onKeyEvent(KBD_FLAGS_DOWN, e); };
const onKeyEventDown = (e) => { onKeyEvent(KBD_FLAGS_RELEASE, e); };

function run()
{
    rdpclient = createRdpClient(
        "ws://localhost:8080",
        user_input.value,
        pass_input.value,
        0/*xff*/);
    document.addEventListener('keyup', onKeyEventUp)
    document.addEventListener('keydown', onKeyEventDown)
    rdpclient.on('socketClose', () => {
        console.log('RdpClient close');
        document.removeEventListener('keyup', onKeyEventUp)
        document.removeEventListener('keydown', onKeyEventDown)
    });
    rdpclient.on('drawImage', canvas.putImageData.bind(canvas));
    rdpclient.on('drawRect', function(x, y, w, h, color) {
        canvas.fillStyle = color;
        canvas.fillRect(x,y,w,h);
    });
    rdpclient.on('drawSrcBlt', function(sx, sy, w, h, dx, dy, rop) {
        const sourceImageData = canvas.getImageData(sx, sy, w, h);
        const op = scrROp[rop]
        if (op) {
            if (has_intersection(x,y,w,h,dx,dy,w,h)) {
                canvas.globalCompositeOperation = op
                canvas.drawImage(sourceImageData, dx, dy);
                canvas.globalCompositeOperation = 'source-over'
            }
            else {
                canvas.putImageData(sourceImageData, dx, dy);
            }
        }
    });
    rdpclient.on('drawLineTo', function(backMode, nXStart, nYStart, nXEnd, nYEnd, backColor, penStyle, penWidth, penColor) {
		canvas.save();
		canvas.beginPath();
		canvas.moveTo(nXStart, nYStart);
		canvas.lineTo(nXEnd, nYEnd);
		canvas.lineWidth = penWidth;
		canvas.fillStyle = backColor;
		canvas.strokeStyle = penColor;
		switch (penStyle) {
		case 1: canvas.setLineDash([ 10, 6, 10, 6 ]); break;
		case 2: canvas.setLineDash([ 3, 3, 3, 3 ]); break;
		case 3: canvas.setLineDash([ 9, 6, 3, 6 ]); break;
		case 4: canvas.setLineDash([ 9, 3, 3, 3 ]); break;
		default: canvas.setLineDash([ 16, 0, 16, 0 ]);
		}
		canvas.setLineDash([ 16, 0, 16, 0 ]);
		// BackMode does not imply the transparency level of what is about too be drawn
        // canvas.globalAlpha = (backMode == 1 /* TRANSPARENT */? 0.0 : 1.0);
		canvas.stroke();
		canvas.restore();
    });
    rdpclient.on('drawPolyline', function(xStart, yStart, deltas, penColor) {
		canvas.save();
		canvas.strokeStyle = penColor;
		canvas.beginPath();
		canvas.moveTo(xStart, yStart);
        let endx = xStart;
        let endy = yStart;
        const iend = deltas.length
		for (let i = 0; i < iend; i += 2) {
			endx += deltas[i];
			endy += deltas[i+1];
			canvas.lineTo(endx, endy);
		}
		canvas.stroke();
		canvas.restore();
    });
}

login.onsubmit = (e) => {
    e.preventDefault();
    if (rdpclient) {
        rdpclient.close();
    }
    run();
};

canvas.fillStyle = 'black';
canvas.fillRect(0,0,800,600);

const stringvalues = document.URL.split('?')[1];
if (stringvalues) {
    const inputs = {user: user_input, pass: pass_input};
    for (const strvalue of stringvalues.split('&')) {
        const kv = strvalue.split('=');
        const input = inputs[kv[0]]
        if (input) {
            input.value = kv[1].replace('#')
        }
    }
}

run();

// const bytearray = new Uint8Array(event.data)
// let text = ""
// // console.log('Received Binary Message of ' + bytearray.length + ' bytes')
// for (let byte of bytearray) {
//     text += ":" + (byte+0x10000).toString(16).substr(-2)
// }
// console.log("Server Says: " + text)
</script>

</body>
</html>
